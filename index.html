<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hex Tile Game</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        background-color: #f0f0f0;
      }
      svg {
        background-color: white;
      }
      .hex {
        fill: lightblue;
        stroke: black;
        stroke-width: 2px;
        cursor: pointer;
      }
      .marker {
        fill: red;
      }
      .highlight {
        fill: yellow;
      }
      .valid-move {
        fill: lightgreen;
      }
    </style>
  </head>
  <body>
    <h1>Hex Tile Game</h1>
    <svg
      id="hexGrid"
      width="800"
      height="600"
      viewBox="-400 -300 800 600"
    ></svg>
    <button id="confirm">Confirm Placement</button>

    <script>
      // Ordered pairs (dq, dr) for directions in axial hex coordinates.
      const ORDERED_DIRECTIONS = [
        [1, 0], // Southeast
        [0, 1], // South
        [-1, 1], // Southwest
        [-1, 0], // Northwest
        [0, -1], // North
        [1, -1], // Northeast
      ];

      /**
       * Rectangular coordinates of a point.
       */
      class RectPoint {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        scale(s) {
          return new RectPoint(this.x * s, this.y * s);
        }
      }

      /**
       * Axial coordinates of a point in a hex grid.
       */
      class HexPoint {
        constructor(q, r) {
          this.q = q;
          this.r = r;
        }

        toRectPoint() {
          let x = 1.5 * this.q;
          let y = Math.sqrt(3) * (0.5 * this.q + this.r);
          return new RectPoint(x, y);
        }

        toKey() {
          return `${this.q},${this.r}`;
        }

        getNeighbors() {
          return ORDERED_DIRECTIONS.map(([dq, dr]) => {
            return new HexPoint(this.q + dq, this.r + dr);
          });
        }
      }

      function hexPointFromKey(key) {
        const [q, r] = key.split(",").map(Number);
        return new HexPoint(q, r);
      }

      class Hex {
        constructor(hexPoint, rotation = 0, connectableEdges = []) {
          this.hexPoint = hexPoint;
          this.rotation = rotation;
          this.connectableEdges = connectableEdges;
        }

        hasConnectableEdge(directionIndex) {
          return this.connectableEdges.includes(
            (directionIndex - this.rotation) % 6
          );
        }

        getConnectableNeighborHexPoints() {
          return this.connectableEdges.map((edge) => {
            const rotatedEdge = (edge + this.rotation) % 6;
            const [dq, dr] = ORDERED_DIRECTIONS[rotatedEdge];
            return new HexPoint(this.hexPoint.q + dq, this.hexPoint.r + dr);
          });
        }
      }

      function makeHexElement(hex, isCurrent = false, isValidMove = false) {
        const rectPoint = hex.hexPoint.toRectPoint().scale(HEX_SIZE);
        const { x, y } = { x: rectPoint.x, y: rectPoint.y };
        const points = [];
        for (let i = 0; i < 6; i++) {
          let angle = (Math.PI / 3) * i;
          let px = x + HEX_SIZE * Math.cos(angle);
          let py = y + HEX_SIZE * Math.sin(angle);
          points.push(`${px},${py}`);
        }
        const hexElement = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "polygon"
        );
        const groupElement = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "g"
        );

        hexElement.setAttribute("points", points.join(" "));
        hexElement.classList.add("hex");
        if (isCurrent) hexElement.classList.add("highlight");
        if (isValidMove) hexElement.classList.add("valid-move");

        groupElement.appendChild(hexElement);

        for (const connectableEdge of hex.connectableEdges) {
          const markerElement = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          const angle =
            Math.PI / 6 + ((connectableEdge + hex.rotation) * Math.PI) / 3;
          const cx = x + 0.7 * HEX_SIZE * Math.cos(angle);
          const cy = y + 0.7 * HEX_SIZE * Math.sin(angle);
          markerElement.setAttribute("r", HEX_SIZE / 10);
          markerElement.setAttribute("cx", cx);
          markerElement.setAttribute("cy", cy);
          markerElement.classList.add("marker");
          groupElement.appendChild(markerElement);
        }

        return groupElement;
      }

      const svg = document.getElementById("hexGrid");
      const confirmButton = document.getElementById("confirm");
      const HEX_SIZE = 40; // Distance from the center to a corner.

      let placedHexes = new Map();
      let currentHex = null;
      let possiblePositions = [];

      function generateFirstHex() {
        const hex = new Hex(new HexPoint(0, 0), 0, [0, 1, 2, 3, 4]);
        const firstHexElement = makeHexElement(hex);
        svg.appendChild(firstHexElement);
        placedHexes.set("0,0", hex);
        generateNewHex();
      }

      function generateNewHex() {
        const allValidHexPointKeys = new Set();
        for (const placedHex of placedHexes.values()) {
          const connectableNeighborHexPoints =
            placedHex.getConnectableNeighborHexPoints();
          for (const hexPoint of connectableNeighborHexPoints) {
            allValidHexPointKeys.add(hexPoint.toKey());
          }
        }

        if (allValidHexPointKeys.size === 0) {
          alert("Game over!");
          return;
        }

        let currentHexPoint = null;

        for (const key of allValidHexPointKeys) {
          const hexPoint = hexPointFromKey(key);
          if (currentHexPoint === null) {
            currentHexPoint = hexPoint;
          }
          if (!placedHexes.has(key)) {
            const hex = new Hex(hexPoint);
            const hexElement = makeHexElement(hex, false, true);
            svg.appendChild(hexElement);
            hexElement.addEventListener("click", () => {
              // TODO: Can we keep the old element around and just change its
              // position and rotation so that we get a CSS animation?
              if (currentHex !== null && currentHex.parentNode) {
                currentHex.parentNode.removeChild(currentHex);
              }
              let rotation = 0;
              for (const neighbor of hexPoint.getNeighbors()) {
                const placedNeighbor = placedHexes.get(neighbor.toKey());
                if (placedHexes.has(neighbor.toKey())) {
                  const [dq, dr] = [
                    hexPoint.q - neighbor.q,
                    hexPoint.r - neighbor.r,
                  ];
                  let direction = -1;
                  for (let i = 0; i < 6; i++) {
                    if (
                      ORDERED_DIRECTIONS[i][0] === dq &&
                      ORDERED_DIRECTIONS[i][1] === dr
                    ) {
                      direction = i;
                      break;
                    }
                  }
                  if (direction === -1) {
                    continue;
                  }
                  if (placedNeighbor.hasConnectableEdge(direction)) {
                    rotation = (direction + 3 - 1) % 6; // The -1 is to hook to the first direction. We need to store the first direction of the current hex somewhere.
                    break;
                  }
                }
              }

              currentHex = makeHexElement(
                new Hex(hexPoint, rotation, [1, 3]),
                true
              );
              svg.appendChild(currentHex);
            });
          }
        }

        currentHex = makeHexElement(new Hex(currentHexPoint, 0, [1, 3]), true);
        svg.appendChild(currentHex);
      }

      confirmButton.addEventListener("click", () => {
        if (currentHex) {
          placedHexes.set(`${currentHex.q},${currentHex.r}`, currentHex);
          document.querySelectorAll(".valid-move").forEach((e) => e.remove());
          document.querySelector(".highlight").classList.remove("highlight");
          generateNewHex();
        }
      });

      generateFirstHex();
    </script>
  </body>
</html>
